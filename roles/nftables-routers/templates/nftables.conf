#!/usr/bin/nft -f
#
# For reference information, see:
#
# * nft(8)
# * /usr/share/nftables/
# * https://wiki.nftables.org/wiki-nftables/index.php/Main_Page
# * `nft describe tcp dport`
#
# Interfaces of interest, in order from closest to the serial port to furthest
# from the serial port:
#
# {{ nftables_routers_dmz_if }}
#     DMZ. Clients may initiate connections to the WAN.
# {{ nftables_routers_lan_if }}
#     LAN. Clients may initiate connections to anywhere.
# {{ nftables_routers_wan_if }}
#     WAN. Clients may initiate certain connections to the DMZ.
# {{ nftables_routers_wap_if }}
#     WAP. Clients may initiate certain connections to anywhere.
define pine_ip = 192.168.10.2
define public_ip = 73.238.210.208
define mnemosyne_sync = 8512
define syncthing_core_ichimonji10 = 22000

table inet filter {
  chain input {
    type filter hook input priority 0; policy drop;

    ct state {established, related} accept
    ct state invalid drop

    ip protocol icmp accept
    ip6 nexthdr icmpv6 accept
    tcp dport ssh accept

    iifname lo accept
    iifname {{ nftables_routers_dmz_if }} jump input_from_dmz
    iifname {{ nftables_routers_lan_if }} jump input_from_lan
    iifname {{ nftables_routers_wan_if }} jump input_from_wan
    iifname {{ nftables_routers_wap_if }} jump input_from_wap

    # Returning port-unreachable is more polite than `drop`.
    reject with icmp type port-unreachable
  }
  chain forward {
    type filter hook forward priority 0; policy drop;

    ct state {established, related} accept
    ct state invalid drop

    iifname lo accept
    iifname {{ nftables_routers_dmz_if }} jump forward_from_dmz
    iifname {{ nftables_routers_lan_if }} accept
    iifname {{ nftables_routers_wan_if }} jump forward_from_wan
    iifname {{ nftables_routers_wap_if }} accept
  }
  chain output {
    type filter hook output priority 0; policy accept;
  }

  # Per-interface input chains.
  chain input_from_dmz {
    tcp dport {bootps, domain} accept
    udp dport {bootps, domain} accept
    return
  }
  chain input_from_lan {
    tcp dport {bootps, domain} accept
    udp dport {bootps, domain} accept
    return
  }
  chain input_from_wan {
    # The WAN interface is *NOT A DHCP SERVER*! Yes, DHCP clients should listen
    # for traffic. See RFC 2131 section 4.1, and
    # http://stackoverflow.com/questions/1790960/why-dhcp-client-listens-on-port-68
    tcp dport bootpc accept
    udp dport bootpc accept
    return
  }
  chain input_from_wap {
    tcp dport {bootps, domain} accept
    udp dport {bootps, domain} accept
    return
  }

  # Per-interface forward chains.
  chain forward_from_dmz {
    oifname {{ nftables_routers_wan_if }} accept
    return
  }
  chain forward_from_wan {
    oifname {{ nftables_routers_dmz_if }} jump forward_to_dmz
    return
  }
  chain forward_to_dmz {
    tcp dport {
      $mnemosyne_sync,
      $syncthing_core_ichimonji10,
      http,
      https
    } accept
  }
}

# See:
#
# * https://wiki.archlinux.org/index.php/Nftables#Masquerading
# * https://wiki.nftables.org/wiki-nftables/index.php/Performing_Network_Address_Translation_(NAT)
table ip nat {
  # Applies to forwarded packets before routing rules are evaluated.
  #
  # The `ip daddr` rules match traffic from both the LAN and WAN. Thus, they're
  # the only rules really needed for DNAT. But using a hard-coded IP address is
  # fragile, as the upstream ISP can issue a new IP address at any time. The
  # `iifname` rules match WAN traffic even when the hard-coded IP address is
  # wrong.
  #
  # Using a hard-coded IP address sucks.  For a possible solution, see "LINUX
  # Networking Cookbook," by Carla Schroder, section 3.14: "Running Public
  # Services on Private IP Addresses."
  #
  # It should be possible to use maps to condense these rules, but nftables has
  # thrown errors when I've tried. See:
  #
  # * https://wiki.nftables.org/wiki-nftables/index.php/Maps
  # * https://wiki.nftables.org/wiki-nftables/index.php/Multiple_NATs_using_nftables_maps
  chain prerouting {
    type nat hook prerouting priority 0; policy accept;
    iifname {{ nftables_routers_wan_if }} tcp dport $mnemosyne_sync dnat to $pine_ip
    iifname {{ nftables_routers_wan_if }} tcp dport $syncthing_core_ichimonji10 dnat to $pine_ip
    iifname {{ nftables_routers_wan_if }} tcp dport http dnat to $pine_ip
    iifname {{ nftables_routers_wan_if }} tcp dport https dnat to $pine_ip

    ip daddr $public_ip tcp dport $mnemosyne_sync dnat to $pine_ip
    ip daddr $public_ip tcp dport $syncthing_core_ichimonji10 dnat to $pine_ip
    ip daddr $public_ip tcp dport http dnat to $pine_ip
    ip daddr $public_ip tcp dport https dnat to $pine_ip
  }
  # Applies to forwarded packets after routing rules are evaluated.
  #
  # "Masquerade is a special case of SNAT, where the source address is
  # automagically set to the address of the output interface."
  chain postrouting {
    type nat hook postrouting priority 0; policy accept;
    oifname {{ nftables_routers_wan_if }} masquerade
  }
}

# vim:set ts=2 sw=2 et:
