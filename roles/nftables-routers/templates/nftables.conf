#!/usr/bin/nft -f
#
# For reference information, see:
#
# * nft(8)
# * https://wiki.nftables.org/wiki-nftables/index.php/Main_Page
#
# Interfaces of interest, in order from closest to the serial port to furthest
# from the serial port:
#
# {{ nftables_routers_dmz_if }}
#     DMZ. Clients may initiate connections to the WAN.
# {{ nftables_routers_lan_if }}
#     LAN. Clients may initiate connections to anywhere.
# {{ nftables_routers_wan_if }}
#     WAN. Clients may initiate certain connections to the DMZ.
# {{ nftables_routers_wap_if }}
#     WAP. Clients may initiate certain connections to anywhere.
define pine_ip = 192.168.10.2
define mnemosyne_sync = 8512
define syncthing_core_ichimonji10 = 22000

define forwarded_tcp_ports = {
  $mnemosyne_sync,
  $syncthing_core_ichimonji10,
  http,
  https
}

table inet filter {
  # Base chains.
  #
  # Ending chains with ICMP rejection notices gives clients faster feedback than
  # just dropping, and reduces traffic by avoiding retransmissions.
  chain input {
    type filter hook input priority 0; policy drop;

    ct state {established, related} accept
    ct state invalid drop

    ip protocol icmp accept
    ip6 nexthdr icmpv6 accept
    tcp dport ssh accept

    iifname lo accept
    iifname {{ nftables_routers_dmz_if }} jump input_from_dmz
    iifname {{ nftables_routers_lan_if }} jump input_from_lan
    iifname {{ nftables_routers_wan_if }} jump input_from_wan
    iifname {{ nftables_routers_wap_if }} jump input_from_wap

    reject with icmpx type port-unreachable
  }
  chain forward {
    type filter hook forward priority 0; policy drop;

    ct state {established, related} accept
    ct state invalid drop

    iifname lo accept
    iifname {{ nftables_routers_dmz_if }} jump forward_from_dmz
    iifname {{ nftables_routers_lan_if }} accept
    iifname {{ nftables_routers_wan_if }} jump forward_from_wan
    iifname {{ nftables_routers_wap_if }} accept

    reject with icmpx type no-route
  }
  chain output {
    type filter hook output priority 0; policy accept;
  }

  # Per-interface input chains.
  chain input_from_dmz {
    tcp dport {bootps, domain} accept
    udp dport {bootps, domain} accept
    return
  }
  chain input_from_lan {
    tcp dport {bootps, domain} accept
    udp dport {bootps, domain} accept
    return
  }
  chain input_from_wan {
    # DHCP clients must listen for responses on a fixed port. See RFC 2131
    # (especially section 4.1) and:
    # http://stackoverflow.com/questions/1790960/why-dhcp-client-listens-on-port-68
    tcp dport bootpc accept
    udp dport bootpc accept
    return
  }
  chain input_from_wap {
    tcp dport {bootps, domain} accept
    udp dport {bootps, domain} accept
    return
  }

  # Per-interface forward chains.
  chain forward_from_dmz {
    oifname {{ nftables_routers_dmz_if }} jump forward_to_dmz
    oifname {{ nftables_routers_wan_if }} accept
    return
  }
  chain forward_from_wan {
    oifname {{ nftables_routers_dmz_if }} jump forward_to_dmz
    return
  }
  chain forward_to_dmz {
    tcp dport $forwarded_tcp_ports accept
  }
}

table ip nat {
  # Mangle packets before routing rules are evaluated.
  chain prerouting {
    type nat hook prerouting priority -100; policy accept;

    # * → DMZ DNAT
    ip daddr aronia.jerebear.name tcp dport $forwarded_tcp_ports dnat to $pine_ip
  }

  # Mangle packets after routing rules are evaluated.
  #
  # "Masquerade is a special case of SNAT, where the source address is
  # automagically set to the address of the output interface."
  chain postrouting {
    type nat hook postrouting priority 100; policy accept;

    # * → WAN SNAT
    oifname enp3s0 masquerade

    # DMZ → DMZ SNAT
    #
    # Without this, a TCP handshake from one DMZ host to another proceeds as
    # described in the following table. Note the DNAT between steps 1 and 2.
    #
    # ============  ==============  =============  ==============  ===========
    # L2 source     L2 destination  L3 source      L3 destination  packet type
    # ============  ==============  =============  ==============  ===========
    # dmz-1         router-dmz      dmz-1          router-wan      TCP SYN
    # router-dmz    dmz-2           dmz-1          dmz-2           TCP SYN
    # dmz-2         dmz-1           dmz-2          dmz-1           TCP SYN/ACK
    # ============  ==============  =============  ==============  ===========
    #
    # This ends with host dmz-1 rejecting the SYN/ACK packet because the L3
    # source is unexpected. Also see: https://unix.stackexchange.com/a/282094
    #
    # For whatever reason, this rule doesn't work if `ip saddr …` is replaced
    # with `iifname {{ nftables_routers_dmz_if }}`.
    ip saddr 192.168.10.0/24 oifname {{ nftables_routers_dmz_if }} masquerade
  }
}

# vim:set ts=2 sw=2 et:
