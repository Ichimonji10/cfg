#!/usr/bin/nft -f
#
# For reference information, see:
#
# * nft(8)
# * /usr/share/nftables/
# * https://wiki.nftables.org/wiki-nftables/index.php/Main_Page
# * `nft describe tcp dport`
#
# Interfaces of interest, in order from closest to the serial port to furthest
# from the serial port:
#
# {{ nftables_routers_dmz_if }}
#     DMZ. Clients may initiate connections to the WAN.
# {{ nftables_routers_lan_if }}
#     LAN. Clients may initiate connections to anywhere.
# {{ nftables_routers_wan_if }}
#     WAN. Clients may initiate certain connections to the DMZ.
# {{ nftables_routers_wap_if }}
#     WAP. Clients may initiate certain connections to anywhere.
define pine_ip = 192.168.10.2
define public_ip = 73.238.210.208
define mnemosyne_sync = 8512
define syncthing_core_ichimonji10 = 22000

table inet filter {
  chain input {
    type filter hook input priority 0; policy drop;

    ct state {established, related} accept
    ct state invalid drop

    ip protocol icmp accept
    ip6 nexthdr icmpv6 accept
    tcp dport ssh accept

    iifname lo accept
    iifname {{ nftables_routers_dmz_if }} jump input_from_dmz
    iifname {{ nftables_routers_lan_if }} jump input_from_lan
    iifname {{ nftables_routers_wan_if }} jump input_from_wan
    iifname {{ nftables_routers_wap_if }} jump input_from_wap

    # Returning port-unreachable is more polite than `drop`.
    reject with icmp type port-unreachable
  }
  chain forward {
    type filter hook forward priority 0; policy drop;

    ct state {established, related} accept
    ct state invalid drop

    iifname lo accept
    iifname {{ nftables_routers_dmz_if }} jump forward_from_dmz
    iifname {{ nftables_routers_lan_if }} accept
    iifname {{ nftables_routers_wan_if }} jump forward_from_wan
    iifname {{ nftables_routers_wap_if }} accept
  }
  chain output {
    type filter hook output priority 0; policy accept;
  }

  # Per-interface input chains.
  chain input_from_dmz {
    tcp dport {bootps, domain} accept
    udp dport {bootps, domain} accept
    return
  }
  chain input_from_lan {
    tcp dport {bootps, domain} accept
    udp dport {bootps, domain} accept
    return
  }
  chain input_from_wan {
    # The WAN interface is *NOT A DHCP SERVER*! Yes, DHCP clients should listen
    # for traffic. See RFC 2131 section 4.1, and
    # http://stackoverflow.com/questions/1790960/why-dhcp-client-listens-on-port-68
    tcp dport bootpc accept
    udp dport bootpc accept
    return
  }
  chain input_from_wap {
    tcp dport {bootps, domain} accept
    udp dport {bootps, domain} accept
    return
  }

  # Per-interface forward chains.
  chain forward_from_dmz {
    oifname {{ nftables_routers_dmz_if }} jump forward_to_dmz
    oifname {{ nftables_routers_wan_if }} accept
    return
  }
  chain forward_from_wan {
    oifname {{ nftables_routers_dmz_if }} jump forward_to_dmz
    return
  }
  chain forward_to_dmz {
    tcp dport {
      $mnemosyne_sync,
      $syncthing_core_ichimonji10,
      http,
      https
    } accept
  }
}

# See:
#
# * https://wiki.nftables.org/wiki-nftables/index.php/Performing_Network_Address_Translation_(NAT)
# * https://wiki.nftables.org/wiki-nftables/index.php/Configuring_chains
#   (Especially the "base chain priority" section.)
table ip nat {

  # Mangle packets before routing rules are evaluated.
  chain prerouting {
    type nat hook prerouting priority -100; policy accept;

    # WAN → DMZ DNAT
    iifname {{ nftables_routers_wan_if }} tcp dport $mnemosyne_sync dnat to $pine_ip
    iifname {{ nftables_routers_wan_if }} tcp dport $syncthing_core_ichimonji10 dnat to $pine_ip
    iifname {{ nftables_routers_wan_if }} tcp dport http dnat to $pine_ip
    iifname {{ nftables_routers_wan_if }} tcp dport https dnat to $pine_ip

    # * → DMZ DNAT
    ip daddr $public_ip tcp dport $mnemosyne_sync dnat to $pine_ip
    ip daddr $public_ip tcp dport $syncthing_core_ichimonji10 dnat to $pine_ip
    ip daddr $public_ip tcp dport http dnat to $pine_ip
    ip daddr $public_ip tcp dport https dnat to $pine_ip
  }

  # Mangle packets after routing rules are evaluated.
  #
  # "Masquerade is a special case of SNAT, where the source address is
  # automagically set to the address of the output interface."
  chain postrouting {
    type nat hook postrouting priority 100; policy accept;

    # * → WAN SNAT
    oifname enp3s0 masquerade

    # DMZ → DMZ SNAT
    #
    # Without this, a TCP handshake from one DMZ host to another proceeds as
    # described in the following table. Note the DNAT between steps 1 and 2.
    #
    # ============  ==============  =============  ==============  ===========
    # L2 source     L2 destination  L3 source      L3 destination  packet type
    # ============  ==============  =============  ==============  ===========
    # dmz-1         router-dmz      dmz-1          router-wan      TCP SYN
    # router-dmz    dmz-2           dmz-1          dmz-2           TCP SYN
    # dmz-2         dmz-1           dmz-2          dmz-1           TCP SYN/ACK
    # ============  ==============  =============  ==============  ===========
    #
    # This ends with host dmz-1 rejecting the SYN/ACK packet because the L3
    # source is unexpected. Also see: https://unix.stackexchange.com/a/282094
    #
    # For whatever reason, this rule doesn't work if `ip saddr …` is replaced
    # with `iifname {{ nftables_routers_dmz_if }}`.
    ip saddr 192.168.10.0/24 oifname {{ nftables_routers_dmz_if }} masquerade
  }
}

# vim:set ts=2 sw=2 et:
